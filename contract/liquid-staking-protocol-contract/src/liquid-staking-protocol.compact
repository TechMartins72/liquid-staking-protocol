pragma language_version >= 0.16.0 && <= 0.18.0;

import CompactStandardLibrary;
import "./CustomLibrary";

export ledger stakes: Map<Bytes<32>, StakeInfo>; // keeps track of stakes and it current position: active or closed
export ledger stakesVault: QualifiedCoinInfo; // keeps track of staked tDust
ledger tokenToBurn: QualifiedCoinInfo; // temporarily holds token to burn

constructor(initialNonce: Bytes<32>) {
    nonce = disclose(initialNonce);
    nonceUniqueIndex.increment(1);
}

witness local_secret_key(): Bytes<32>;
witness generateStakeId(): Bytes<32>;
witness getTime(): Uint<64>;
witness getTotalValue(amount: Uint<64>, time: Uint<64>): Uint<64>;

export circuit stakeAsset(coin: CoinInfo): [] {
    assert (coin.value > 0, "Stake amount must be greater than 0");
    
    const disclosedCoin = disclose(coin);
    const stakeTime = disclose(getTime());
    const staker = disclose(public_key(local_secret_key()));
    const stakedAmount = disclosedCoin.value as Uint<64>;

    receive(disclosedCoin);

    const coinInfo = mergeCoinImmediate(stakesVault, disclosedCoin);
    stakesVault.writeCoin(coinInfo, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    mintToken(stakedAmount);

    TVL = stakedAmount + TVL as Uint<128>;

    stakes.insert(disclose(generateStakeId()), StakeInfo {
        staker,
        stakedAmount,
        State.open,
        stakeTime,
        closedTime: 0
    });
    return;
}

export circuit redeemAsset(coin: CoinInfo, stakeId: Bytes<32>): []  {
    // receive the skDust token, stakeID
    const disclosedCoin = disclose(coin);
    const disclosedId = disclose(stakeId);
    const disclosedAmount = disclose(disclosedCoin.value);

    // confirm token type and stake existence and state
    assert(disclosedCoin.color == stakesVault.color, "Unacceptable token");
    const stakeExist = stakes.member(disclosedId);
    assert (stakeExist, "This stake does not exist");
    
    const stakeInfo = stakes.lookup(disclosedId);
    assert(stakeInfo.status == State.open, "This stake is closed");
    assert(disclose(public_key(local_secret_key())) == stakeInfo.staker, "This stake does not belong to you");
    // sned received stDUST to a burn address to reduce the amount of stDust in circulation
    
    receive(disclosedCoin);
    tokenToBurn.writeCoin(disclosedCoin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
    
    const burnAdr = burnAddress();
    send(tokenToBurn, burnAdr, disclosedAmount);

    // send staked token back to user
    const totalValue = disclose(getTotalValue(stakeInfo.stakedAmount, stakeInfo.stakeTime));
    const sendResult = send(stakesVault, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), totalValue);
    
    sendResult.change.is_some && stakesVault.writeCoin(sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
    
    TVL = TVL - totalValue;
    return;
}

export circuit addDailyReward(coin: CoinInfo): [] {
    const disclosedCoin = disclose(coin);
    const stakedAmount = disclosedCoin.value as Uint<64>;

    receive(disclosedCoin);

    const coinInfo = mergeCoinImmediate(stakesVault, disclosedCoin);
    stakesVault.writeCoin(coinInfo, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));

    TVL = stakedAmount + TVL as Uint<128>;

}

export circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Vector<2, Bytes<32>>>([pad(32, "mn-liquidstake"), sk]);
}