module Utils {
    import CompactStandardLibrary;
    import GlobalStatesAndWitnesses;
        
    export circuit mintNewToken(amount: Uint<64>) :[] {
        const disclosedAmount = disclose(amount);
        const newTokenNonce = evolveNonce(mintCounter, nonce);

        mintToken(
        stAssetDomainSeparator,
        disclose(disclosedAmount),
        newTokenNonce,
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())
        );
        mintCounter.increment(1);
        total_stAsset_Minted = (total_stAsset_Minted as Uint<64>) + disclosedAmount;
    }

    export circuit calculateMintCapacity(dep_amount: Uint<128>): Uint<128>{
        const disclosedDepositAmount = disclose(dep_amount);

        if(total_stAsset_Minted == 0){
            return disclosedDepositAmount; // Allow mint on a 1:1 ratio
        }else{
            const exchangeRatio = ScaledDivisionFunction((total_stAsset_Minted * SCALE_FACTOR) as Uint<64>, protocolTVL.value as Uint<64>);

             const amountMintable = ScaledDivisionFunction((disclosedDepositAmount * exchangeRatio) as Uint<64>, SCALE_FACTOR);

             return amountMintable; // Allow mint based on underlying stake assset in the pool
        }
    }

    export circuit ScaledDivisionFunction(numerator: Uint<64>, denominator: Uint<64>): Uint<64>{
        assert (numerator > 0, "Invalid arithemetic operation");
        const disclosedNumerator = disclose(numerator);
        const disclosedDenominator = disclose(denominator);

        const [quotient, remainder] = disclose(divide(disclosedNumerator, disclosedDenominator));

        assert(remainder < denominator, "Invalid divsion results");
        assert ((quotient * denominator) + remainder == numerator, "Invalid division results");

        return quotient;
    }

    export circuit generatePrivateStateHash(metadata: StakePrivateState, stakerId: Bytes<32>): Bytes<32>{
        return persistentCommit<StakePrivateState>(
            metadata,
            stakerId
        );
    }

    export circuit generateStakerId(sk: Bytes<32>): Bytes<32>{
        return persistentHash<Vector<2, Bytes<32>>>([
            pad(32, "hydra:staker"),
            persistentHash<Vector<2, Bytes<32>>>([
               sk,
               kernel.self().bytes
            ])
        ]);
    }

    export circuit recieveAndAddCoinToTvl(disclosedCoin: CoinInfo): []{
        receive(disclosedCoin);

        /** Update the ledger balance */
        const coinToInsert = protocolTVL.value > 0 ? 
        mergeCoinImmediate(protocolTVL, disclosedCoin) :
        disclosedCoin;

        protocolTVL.writeCoin(
            coinToInsert,
            right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    }

    export circuit burnReturnedstAsset(coin: CoinInfo):[] {
        const disclosedCoin = disclose(coin);
        assert (disclosedCoin.color == stAssetCoinColor, "Invalid coin type provided to cover transaction");
        
        receive(disclosedCoin);
        /** Immediately burn */
        sendImmediate(coin, burnAddress(), disclosedCoin.value);
    }

    export circuit sendAndManageChange(amount: Uint<128>, address: ZswapCoinPublicKey): []{
        const disclosedAmt = disclose(amount);
        /** Update the ledger balance */
        const sendResult = send(protocolTVL, left<ZswapCoinPublicKey, ContractAddress>(address), disclosedAmt);
        if(sendResult.change.is_some){
            protocolTVL.writeCoin(
                sendResult.change.value,
                right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        }else{
            protocolTVL.resetToDefault();
        }
    }
}